# Entity Framework Core 2: Getting Started

## Packages that need to be installed

EF Core APIs are not all packaged into a single assembly. EF Core does not assume that, just because you are using one feature, you are going to be using all the features.

- **Microsoft.EntityFrameworkCore:** The base core package of EF Core (does not include the specific database provider)
- **Microsoft.EntityFrameworkCore.SqlServer:** The SQL Server provider for EF Core (NuGet’s dependencies functionality will also install the Microsoft.EntityFrameworkCore base package if you install this.)
- **Microsoft.EntityFrameworkCore.Tools:** Needed to run migrations. Add it to the data project in your solution.
- **Microsoft.EntityFrameworkCore.Design:** Needed in your startup project to support EF Core functionality. Be sure to also add references to your data and domain projects to your startup project and mark your startup project in VisualStudio as the startup project of your solution.
- **Microsoft.Extensions.Logging.Console:** Needed to log the SQL that is generated by EF Core. Install this into your data project.

## Migration Commands

Open the *Package Manager Console* and make sure the selected *Default project* is set to your *data* project.

To see the PowerShell commands for EF Core type:
get-help entityframeworkcore

**add-migration:** Adds a new migration<br/>
**drop-database:** Drops the database<br/>
**get-dbcontext:** Gets information about a DbContext type<br/>
**remove-migration:** Removes the last migration<br/>
**scaffold-dbcontext:** Scaffolds a DbContext and entity types for a database<br/>
**script-migration:** Generates a SQL script from migrations<br/>
**update-database:** Updates the database to a specified migration<br/>
**scaffold-dbcontext:** Reverse engineer an existing database to model classes

## Relationships

- An example of creating a many-to-many relationship code-first:
  - Create a mapping class (ie SamuraiBattle.cs) that has a SamuraiId and BattleId.
  - Change the Samurai class to have a SamuraiBattles property that returns a list of SamuraiBattle objects.
  - Change the Battle class to have a SamuraiBattles property that returns a list of SamuraiBattle objects.
  - EF Core won’t be able to derive the correct db table relationships that should be set up. You need to add the following code to your DbContext class (SamuraiContext in this example) to guide EF Core to create the correct relationships:
    ```
       protected override void OnModelCreating(ModelBuilder modelBuilder)
       {
          modelBuilder.Entity<SamuraiBattle>().HasKey(obj => new { obj.SamuraiId, obj.BattleId });
       }
    ```
 - An example of creating a one-to-one relationship code-first (using Samurai and SecretIdentity tables/entities):
   - Add a SamuraiId field to the SecretIdentity class:
     ```
     public int SamuraiId { get; set; }
     ```
   - Add a SecretIdentity navigation property to the Samurai class:
     ```
     public SecretIdentity SecretIdentity { get; set; }
     ```
   - These two things are enough for EF Core to comprehend the relationship without anymore information from the developer.
   - Keep in mind that the dependent-end of a one-to-one relationship (in this example Samurai.SecretIdentity) is always optional, as far as EF Core is concerned. There’s no way to apply that constraint in the model or the database. If you want Samurai to require that a SecretIdentity be set, you’ll need to do it in business logic.<br/>
     ![useful image](/assets/images/EntityFrameworkCore2GettingStarted/image01.png)

## Reverse Engineering an Existing Database

- You can reverse engineer an existing database into a new DbContext and classes. Typically, this is a one-time procedure to give you a head start with your code when working with an existing database. At some point, EF Core will support updating the model with database changes, but that is not yet possible with EF Core 2.
- It’s also not currently easy to begin by reverse engineering an existing database, then transition to migrations. Check out the following link for more info: https://cmatskas.com/ef-core-migrations-with-existing-database-schema-and-data
- Example PowerShell command to run in Package Manager Console:
  ```
  scaffold-dbcontext -provider Microsoft.EntityFrameworkCore.SqlServer  -connection "Data Source=(localdb)\MSSQLLocalDB; Initial Catalog=SamuraiLegacyData; Integrated Security=True;Connect Timeout=30;"
  ```
  - **Important Note:** In order for the command to work, make sure that your model project is the default project selected in Package Manager Console. Also, make sure the model project is set as the Startup Project.
- EF Core uses defaults when scaffolding the classes
  - Creates DbSet properties for every one of the entities
  - Puts the connection string in the OnConfiguring handler in the DbContext class
  - Uses ICollection as the type for properties that return collections and sets them to a HashSet.
  - These defaults can be changed
  - You can change and make the classes your own once the scaffolding is done. The scaffold-dbcontext command is only to give you a head start.

## Connected vs Disconnected

- **Connected:** DbContext **is aware** of all changes made to objects that it is tracking
- **Disconnected:** DbContext **has no clue** about history of objects before they are attached

## Interacting with Simple Objects

- To enable logging so you can view the SQL generated by EF Core:
  - Install the Microsoft.Extensions.Logging.Console Nuget package into your data project.
  - Logging code will code into your ***data*** project’s context class (ie. SamaruiContext.cs).
    - Add the using statements to the context class:
      ```
      using Microsoft.Extensions.Logging;
      using Microsoft.Extensions.Logging.Console;
      ```
    - Add a LoggerFactory property to the context class:
      ```
      public static readonly LoggerFactory MyConsoleLoggerFactory = new LoggerFactory(
        new[]
        {
          new ConsoleLoggerProvider
          (
            (category, level) => category == DbLoggerCategory.Database.Command.Name && level == LogLevel.Information,
            true
          )
        }
      );
    - In the OnConfiguring method, tell the model building to use your LoggerFactory:
      ```
      optionsBuilder.UseLoggerFactory(MyConsoleLoggerFactory);
      ```
- Inserting simple objects:
  - Example:
    ```
    var samurai = new Samurai { Name = "Julie" };
    using (var context = new SamuraiContext())
    {
      context.Samurais.Add(samurai);
      context.SaveChanges();
    }
    ```
  - You can also insert multiple objects at the same time:
    ```
    var samurai1 = new Samurai { Name = "Julie" };
    var samurai2 = new Samurai { Name = "Sampson"}; 
    using (var context = new SamuraiContext())
    {
      context.Samurais.AddRange(samurai1, samurai2);
      context.SaveChanges();
    }
    ```
- Querying simple objects
  - Example:
    ```
    var samurais = _context.Samurais.Where(s => s.Name == "Sampson").ToList();
    ```
  - Execution methods:<br/>
    ![useful image](/assets/images/EntityFrameworkCore2GettingStarted/image02.png)
  - **GOTCHA:** When using Last() or LastOrDefault(), you must include an orderby statement in your query. EF constructs the SQL with a descending sort, then returns the top record to memory. If you don’t include ordering, then EF Core won’t be able to construct the SQL that sorts and selects top(1), so instead it returns the full set of results to memory, then EF Core selects the last item from that set and returns it. If you have a lot of results in that query, it could definitely lead to performance problems!
  - Using EF.Functions to filter partial LINQ text:<br/>
    ![useful image](/assets/images/EntityFrameworkCore2GettingStarted/image03.png)
  - When querying the database at the start of an enumeration, the database connection will stay open until the enumeration is complete and all of the results are streamed back. In some cases that’s fine. In other cases, if you start performing a lot of operations on the results WHILE you’re looping through them, it can cause performance and DB concurrency issues.<br/>
  ![useful image](/assets/images/EntityFrameworkCore2GettingStarted/image04.png)<br/>
  A smarter way may be to use an explicit execution method (such as ToList), get all of the results into memory, then do whatever processing you need to do in memory.
  - **NOTE:** A DbContext instance used for multiple operations will keep track of all of the entities used in each of those operations.
- Updating simple object:
  - Example for updating a simple object:<br/>
    ```
    var samurai = _context.Samurais.FirstOrDefault();
    samurai.Name += “San”;
    _context.SaveChanges();
    ```
  - Example for batch updating a collection of objects:<br/>
    ```
    var samurais = _context.Samurais;
    samurais.ForEach(s => s.Name += “San”);
    _context.SaveChanges();
    ```
  - **NOTE:** Batch operations aren’t limited to common operations. You can have a bunch of activities that the context is tracking (updates, inserts, and deletes). When you call SaveChanges() it will still batch them all.
  - Disconnected updates:
    - If you have an entity that has updated property values, and the context that was tracking that entity is no longer in scope, then do the following to do a disconnected update. (You may use this when an object is being updated from an API call.
      ```
      // Assume battle is passed in to the API method.
      // Do the following to update the battle. The resulting SQL updates
      // all properties where the ID = the ID of the battle object that was passed in.
      using (var newContextInstance = new SamuraiContext())
      {
        newContextInstance.Battles.Update(battle);
        newContextInstance.SaveChanges();
      }
      ```
  - Deleting objects:
    - DbContext can only delete objects it is aware of, ie, already tracking.
    - Example:
      ```
      _context.Samurais.Remove(samurai);
      _context.Remove(samurai);
      _context.Samurais.Remove(_context.Samurais.Find(1));
      ```
    - Example of deleting in batch:
      ```
      _context.Samurais.RemoveRange(samurais);
      _context.SaveChanges();
      ```
    - Example of disconnected deletes:
      ```
      contextNewAppInstance.Samurais.Remove(samurai);
      contextNewAppInstance.SaveChanges();
      ```
    - If you don't already have the object you want to delete then you have to first query the database with the Find method, so that you can pass it into the Remove method it to delete it.
      ```
      var samurai = _context.Samurais.Find(samuraiId);
      _context.Remove(samurai);
      _context.SaveChanges();
      ```
    - **Annoying:** Why isn't there a DbSet.Delete(int) method like there is DbSet.Find(int)? It doesn’t exist yet, and it's silly.<br/>
      Alternative idea, use a stored procedure:
      ```
      _context.Database.ExecuteSqlCommand(“exec DeleteById {0}”, samuraiId);
      ```
    - EF Core's raw SQL features:<br/>
      ![useful image](/assets/images/EntityFrameworkCore2GettingStarted/image05.png)
    - Other resources:
      - Entity Framework Core on GitHub: http://github.com/aspnet/entityframework
      - EF Core Roadmap: http://bit.ly/efcoreroadmap
      - EF Core Documentation: http://docs.efproject.net
      - Bulk Operations Commands Explanation by Richie Rump: https://www.brentozar.com/archive/2017/05/case-entity-framework-cores-odd-sql/
      - BreezeJS and Breeze.NET: http://www.getbreezenow.com
      - Trackable entities: http://trackableentities.github.io

## Querying and Saving Related Data

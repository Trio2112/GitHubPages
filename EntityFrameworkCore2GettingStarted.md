<a id="top_anchor"></a>
# Entity Framework Core 2: Getting Started
- [Packages that need to be installed](#packages-that-need-to-be-installed_anchor)
- [Migration Commands](#migration-commands_anchor)
- [Relationships](#relationships_anchor)
- [Reverse Engineering an Existing Database](#reverse-engineering-an-existing-database_anchor)
- [Connected vs Disconnected](#connected-vs-disconnected_anchor)
- [Interacting with Simple Objects](#interacting-with-simple-objects_anchor)
- [Querying and Saving Related Data](#querying-and-saving-related-data_anchor)
- [Other items](#other-items_anchor)

## Packages that need to be installed<a id="packages-that-need-to-be-installed_anchor"></a> <sup><sub>[(back to top)](#top_anchor)</sub></sup>

EF Core APIs are not all packaged into a single assembly. EF Core does not assume that, just because you are using one feature, you are going to be using all the features.

- **Microsoft.EntityFrameworkCore:** The base core package of EF Core (does not include the specific database provider)
- **Microsoft.EntityFrameworkCore.SqlServer:** The SQL Server provider for EF Core (NuGet’s dependencies functionality will also install the Microsoft.EntityFrameworkCore base package if you install this.)
- **Microsoft.EntityFrameworkCore.Tools:** Needed to run migrations. Add it to the data project in your solution.
- **Microsoft.EntityFrameworkCore.Design:** Needed in your startup project to support EF Core functionality. Be sure to also add references to your data and domain projects to your startup project and mark your startup project in VisualStudio as the startup project of your solution.
- **Microsoft.Extensions.Logging.Console:** Needed to log the SQL that is generated by EF Core. Install this into your data project.

## Migration Commands<a id="migration-commands_anchor"></a> <sup><sub>[(back to top)](#git)</sub></sup>

Open the *Package Manager Console* and make sure the selected *Default project* is set to your *data* project.

To see the PowerShell commands for EF Core type:
get-help entityframeworkcore

**add-migration:** Adds a new migration<br/>
**drop-database:** Drops the database<br/>
**get-dbcontext:** Gets information about a DbContext type<br/>
**remove-migration:** Removes the last migration<br/>
**scaffold-dbcontext:** Scaffolds a DbContext and entity types for a database<br/>
**script-migration:** Generates a SQL script from migrations<br/>
**update-database:** Updates the database to a specified migration<br/>
**scaffold-dbcontext:** Reverse engineer an existing database to model classes

## Relationships<a id="relationships_anchor"></a> <sup><sub>[(back to top)](#git)</sub></sup>

- An example of creating a many-to-many relationship code-first:
  - Create a mapping class (ie SamuraiBattle.cs) that has a SamuraiId and BattleId.
  - Change the Samurai class to have a SamuraiBattles property that returns a list of SamuraiBattle objects.
  - Change the Battle class to have a SamuraiBattles property that returns a list of SamuraiBattle objects.
  - EF Core won’t be able to derive the correct db table relationships that should be set up. You need to add the following code to your DbContext class (SamuraiContext in this example) to guide EF Core to create the correct relationships:
    ```
       protected override void OnModelCreating(ModelBuilder modelBuilder)
       {
          modelBuilder.Entity<SamuraiBattle>().HasKey(obj => new { obj.SamuraiId, obj.BattleId });
       }
    ```
 - An example of creating a one-to-one relationship code-first (using Samurai and SecretIdentity tables/entities):
   - Add a SamuraiId field to the SecretIdentity class:
     ```
     public int SamuraiId { get; set; }
     ```
   - Add a SecretIdentity navigation property to the Samurai class:
     ```
     public SecretIdentity SecretIdentity { get; set; }
     ```
   - These two things are enough for EF Core to comprehend the relationship without anymore information from the developer.
   - Keep in mind that the dependent-end of a one-to-one relationship (in this example Samurai.SecretIdentity) is always optional, as far as EF Core is concerned. There’s no way to apply that constraint in the model or the database. If you want Samurai to require that a SecretIdentity be set, you’ll need to do it in business logic.<br/>
     ![useful image](/assets/images/EntityFrameworkCore2GettingStarted/image01.png)

## Reverse Engineering an Existing Database<a id="reverse-engineering-an-existing-database_anchor"></a> <sup><sub>[(back to top)](#git)</sub></sup>

- You can reverse engineer an existing database into a new DbContext and classes. Typically, this is a one-time procedure to give you a head start with your code when working with an existing database. At some point, EF Core will support updating the model with database changes, but that is not yet possible with EF Core 2.
- It’s also not currently easy to begin by reverse engineering an existing database, then transition to migrations. Check out the following link for more info: https://cmatskas.com/ef-core-migrations-with-existing-database-schema-and-data
- Example PowerShell command to run in Package Manager Console:
  ```
  scaffold-dbcontext -provider Microsoft.EntityFrameworkCore.SqlServer  -connection "Data Source=(localdb)\MSSQLLocalDB; Initial Catalog=SamuraiLegacyData; Integrated Security=True;Connect Timeout=30;"
  ```
  - **Important Note:** In order for the command to work, make sure that your model project is the default project selected in Package Manager Console. Also, make sure the model project is set as the Startup Project.
- EF Core uses defaults when scaffolding the classes
  - Creates DbSet properties for every one of the entities
  - Puts the connection string in the OnConfiguring handler in the DbContext class
  - Uses ICollection as the type for properties that return collections and sets them to a HashSet.
  - These defaults can be changed
  - You can change and make the classes your own once the scaffolding is done. The scaffold-dbcontext command is only to give you a head start.

## Connected vs Disconnected<a id="connected-vs-disconnected_anchor"></a> <sup><sub>[(back to top)](#git)</sub></sup>

- **Connected:** DbContext **is aware** of all changes made to objects that it is tracking
- **Disconnected:** DbContext **has no clue** about history of objects before they are attached

## Interacting with Simple Objects<a id="interacting-with-simple-objects_anchor"></a> <sup><sub>[(back to top)](#git)</sub></sup>

- To enable logging so you can view the SQL generated by EF Core:
  - Install the Microsoft.Extensions.Logging.Console Nuget package into your data project.
  - Logging code will code into your ***data*** project’s context class (ie. SamaruiContext.cs).
    - Add the using statements to the context class:
      ```
      using Microsoft.Extensions.Logging;
      using Microsoft.Extensions.Logging.Console;
      ```
    - Add a LoggerFactory property to the context class:
      ```
      public static readonly LoggerFactory MyConsoleLoggerFactory = new LoggerFactory(
        new[]
        {
          new ConsoleLoggerProvider
          (
            (category, level) => category == DbLoggerCategory.Database.Command.Name && level == LogLevel.Information,
            true
          )
        }
      );
    - In the OnConfiguring method, tell the model building to use your LoggerFactory:
      ```
      optionsBuilder.UseLoggerFactory(MyConsoleLoggerFactory);
      ```
- Inserting simple objects:
  - Example:
    ```
    var samurai = new Samurai { Name = "Julie" };
    using (var context = new SamuraiContext())
    {
      context.Samurais.Add(samurai);
      context.SaveChanges();
    }
    ```
  - You can also insert multiple objects at the same time:
    ```
    var samurai1 = new Samurai { Name = "Julie" };
    var samurai2 = new Samurai { Name = "Sampson"}; 
    using (var context = new SamuraiContext())
    {
      context.Samurais.AddRange(samurai1, samurai2);
      context.SaveChanges();
    }
    ```
- Querying simple objects
  - Example:
    ```
    var samurais = _context.Samurais.Where(s => s.Name == "Sampson").ToList();
    ```
  - Execution methods:<br/>
    ![useful image](/assets/images/EntityFrameworkCore2GettingStarted/image02.png)
  - **GOTCHA:** When using Last() or LastOrDefault(), you must include an orderby statement in your query. EF constructs the SQL with a descending sort, then returns the top record to memory. If you don’t include ordering, then EF Core won’t be able to construct the SQL that sorts and selects top(1), so instead it returns the full set of results to memory, then EF Core selects the last item from that set and returns it. If you have a lot of results in that query, it could definitely lead to performance problems!
  - Using EF.Functions to filter partial LINQ text:<br/>
    ![useful image](/assets/images/EntityFrameworkCore2GettingStarted/image03.png)
  - When querying the database at the start of an enumeration, the database connection will stay open until the enumeration is complete and all of the results are streamed back. In some cases that’s fine. In other cases, if you start performing a lot of operations on the results WHILE you’re looping through them, it can cause performance and DB concurrency issues.<br/>
  ![useful image](/assets/images/EntityFrameworkCore2GettingStarted/image04.png)<br/>
  A smarter way may be to use an explicit execution method (such as ToList), get all of the results into memory, then do whatever processing you need to do in memory.
  - **NOTE:** A DbContext instance used for multiple operations will keep track of all of the entities used in each of those operations.
- Updating simple object:
  - Example for updating a simple object:<br/>
    ```
    var samurai = _context.Samurais.FirstOrDefault();
    samurai.Name += “San”;
    _context.SaveChanges();
    ```
  - Example for batch updating a collection of objects:<br/>
    ```
    var samurais = _context.Samurais;
    samurais.ForEach(s => s.Name += “San”);
    _context.SaveChanges();
    ```
  - **NOTE:** Batch operations aren’t limited to common operations. You can have a bunch of activities that the context is tracking (updates, inserts, and deletes). When you call SaveChanges() it will still batch them all.
  - Disconnected updates:
    - If you have an entity that has updated property values, and the context that was tracking that entity is no longer in scope, then do the following to do a disconnected update. (You may use this when an object is being updated from an API call.
      ```
      // Assume battle is passed in to the API method.
      // Do the following to update the battle. The resulting SQL updates
      // all properties where the ID = the ID of the battle object that was passed in.
      using (var newContextInstance = new SamuraiContext())
      {
        newContextInstance.Battles.Update(battle);
        newContextInstance.SaveChanges();
      }
      ```
- Deleting objects:
  - DbContext can only delete objects it is aware of, ie, already tracking.
  - Example:
    ```
    _context.Samurais.Remove(samurai);
    _context.Remove(samurai);
    _context.Samurais.Remove(_context.Samurais.Find(1));
    ```
  - Example of deleting in batch:
    ```
    _context.Samurais.RemoveRange(samurais);
    _context.SaveChanges();
    ```
  - Example of disconnected deletes:
    ```
    contextNewAppInstance.Samurais.Remove(samurai);
    contextNewAppInstance.SaveChanges();
    ```
  - If you don't already have the object you want to delete then you have to first query the database with the Find method, so that you can pass it into the Remove method it to delete it.
    ```
    var samurai = _context.Samurais.Find(samuraiId);
    _context.Remove(samurai);
    _context.SaveChanges();
    ```
  - **Annoying:** Why isn't there a DbSet.Delete(int) method like there is DbSet.Find(int)? It doesn’t exist yet, and it's silly.<br/>
    Alternative idea, use a stored procedure:
    ```
    _context.Database.ExecuteSqlCommand(“exec DeleteById {0}”, samuraiId);
    ```
  - EF Core's raw SQL features:<br/>
    ![useful image](/assets/images/EntityFrameworkCore2GettingStarted/image05.png)
- Other resources:
  - Entity Framework Core on GitHub: http://github.com/aspnet/entityframework
  - EF Core Roadmap: http://bit.ly/efcoreroadmap
  - EF Core Documentation: http://docs.efproject.net
  - Bulk Operations Commands Explanation by Richie Rump: https://www.brentozar.com/archive/2017/05/case-entity-framework-cores-odd-sql/
  - BreezeJS and Breeze.NET: http://www.getbreezenow.com
  - Trackable entities: http://trackableentities.github.io

## Querying and Saving Related Data<a id="querying-and-saving-related-data_anchor"></a> <sup><sub>[(back to top)](#git)</sub></sup>

- Inserting Related Data
  - Example 1:
    ```
    var samurai = _context.Samurais.First();
    samurai.Quotes.Add(new Quote { Text = “I’m here to save you.” });
    _context.SaveChanges();
    ```
  - Example using a disconnected data set (not being tracked by the context):
    ```
    // NOTE: Setting the foreign key is the best and simplest path to success!
    private static void AddChildToExistingObjectWhileNotTracked(int samuraiId)
    {
      var quote = new Quote
      {
        Text = “Now that I saved you, will you feed me dinner?”,
        SamuraiId = samuraiId;
      };
      using (var newContext = new SamuraiContext())
      {
        newContext.Quotes.Add(quote);
        newContext.SaveChanges();
      }
    }
    ```
- Methods to Load Related Data
  - Terms:
    - **Explicit Loading**: Request related data of objects already in memory
    - **Lazy Loading**: On-the-fly retrieval of related data -- This is not currently supported by EF2
    - **Eager Loading**: Including related objects in the query
  - Eager loading examples:
    - Example 1, eager loading to include children:
      ```
      var samuraiWithQuotes = _context.Samurais.Include(s => s.Quotes).ToList();
      ```
    - Example 2, eager loading to include children and grandchildren:
      ```
      var samuraiWithQuotesAndTranslations = 
        _context.Samurais
        .Include(s => s.Quotes)
        .ThenInclude(q => q.Translations);
      ```
    - Example 3, include just grandchildren:
      ```
      _context.Samurais.Include(s => s.Quotes.Translations);
      ```
    - Example 4, Include different children:
      ```
      _context.Samurais.Include(s => s.Quotes).Include(s => s.SecretIdentity);
      ```
    - **IMPORTANT: The Include statement always loads the entire set of related objects.**
  - Query Projections: Defining the shape of query results
    - Use LINQ’s select method to specify which properties of an object you want returned.
    - If you want to return more than a single property, then you’ll need to project the desired properties into an anonymous type.
    - Example 1:
      ```
      var someProperties = _context.Samurais.Select(
        s => s.new {
          s.Id,
          s.Name,
          s.Quotes
        }
      ).ToList();
      ```
    - Example 2:
      ```
      var someProperties = _context.Samurais.Select(
        s => new {
          s.Id,
          s.Name,
          HappyQuotes = s.Quotes.Where(q => q.Text.Contains(“happy”))
        }
      ).ToList();
      ```
    - **NOTE:** If you want a full, related entity you should be able to use projections to get it, something like:
      ```
      var samuraisWithHappyQuotes = 
        _context.Samurais.Select(
          s => new {
            Samurai = s,
            Quotes = s.Quotes.Where(q => q.Text.Contains(“happy”)).ToList()
          }
        ).ToList();
      ```
      **HOWEVER**, this does not work using projections due to an EF Core 2 bug.<br/>
      **INSTEAD**, when you want to filter related objects when you want full types, you have to execute two separate queries.
      ```
      var samurais = _context.Samurais.ToList();
      var happyQuotes = _context.Quotes.Where(q => q.Text.Contains(“happy”)).ToList();
      ```
      When you do this with the same context instance, EF Core will return the related entity (in this case, samurai).
  - Using Related Data to Filter Objects
    ```
    var samurais = _context.Samurais.Where(
      s => s.Quotes.Any(
        q => q.Text.Contains(“happy”)
      )
    ).ToList();
    ```
  - Modifying Related Data
    - DbContext is aware of all changes made to objects that it is tracking.
      - Example 1, updating related data:
        ```
        var samurai = _context.Samurais.Include(s => s.Quotes).FirstOrDefault();
        samurai.Quotes[0].Text += "Did you hear that?";
        _context.SaveChanges();
        ```
     - Example 2, deleting related data:
       ```
       var samurai = _context.Samurais.Include(s => s.Quotes).FirstOrDefault();
       _context.Quotes.Remove(samuri.Quotes[2]);
       _context.SaveChanges();
       ```
  - DbContext has no clue about history of objects before they are attached.
    - Example 1, updating related data:<br/>
      NOTE: The following will result in SQL statements to update all related entities in the graph, even if their data didn’t really change. To update only the quote entity, use the .Entry() method of dbContext.
      ```
      var samurai = _context.Samurais.Include(s => s.Quotes).FirstOrDefault();
      var quote = samurai.Quotes[0];
      quote.Text += “ Did you hear that?”;
      using (var newContext = new SamuraiContext())
      {
        newContext.Quotes.Update(quote);
        newContext.SaveChanges();
      }
      ```
    - Example 2, updating data with the Entry method:
      ```
      var samurai = _context.Samurais.Include(s => s.Quotes).FirstOrDefault();
      var quote = samurai.Quotes[0];
      quote.Text += "Did you hear that?";
      using (var newContext = new SamuraiContext())
      {
        newContext.Entry(quote).State = EntityState.Modified;
        newContext.SaveChanges();
      }
      ```
## Other items<a id="other-items_anchor"></a> <sup><sub>[(back to top)](#git)</sub></sup>
- Pulling the connection string from app.config:
  ```
  protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
  {
    var connectionString = ConfigurationManager.ConnectionStrings[“MyConnString”].ToString();
    optionsBuilder
    .UseLoggerFactory(MyConsoleLoggerFactory)
    .EnableSensitiveDataLogging(true)
    .UseSqlServer(connectionString);
  }
  ```
